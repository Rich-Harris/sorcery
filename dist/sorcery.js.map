{"version":3,"file":"sorcery.js","sources":["../../01-babel/1/utils/decodeMappings.js","../../01-babel/1/utils/atob.js","../../01-babel/1/utils/getMapFromUrl.js","../../01-babel/1/utils/getSourceMappingUrl.js","../../01-babel/1/utils/getMap.js","../../01-babel/1/Node.js","../../01-babel/1/utils/btoa.js","../../01-babel/1/SourceMap.js","../../01-babel/1/utils/encodeMappings.js","../../01-babel/1/Chain.js","../../01-babel/1/index.js"],"sourcesContent":["\n\nexport default decodeMappings;\nimport * as crc32 from 'buffer-crc32';\nimport * as vlq from 'vlq';\n\nvar cache = {};\n\nfunction decodeSegments(encodedSegments) {\n\tvar i = encodedSegments.length;\n\tvar segments = new Array(i);\n\n\twhile (i--) {\n\t\tsegments[i] = vlq.decode(encodedSegments[i]);\n\t}\n\n\treturn segments;\n}\nfunction decodeMappings(mappings) {\n\tvar checksum = crc32(mappings);\n\n\tif (!cache[checksum]) {\n\t\tvar sourceFileIndex = 0; // second field\n\t\tvar sourceCodeLine = 0; // third field\n\t\tvar sourceCodeColumn = 0; // fourth field\n\t\tvar nameIndex = 0; // fifth field\n\n\t\tvar lines = mappings.split(';');\n\t\tvar numLines = lines.length;\n\t\tvar decoded = new Array(numLines);\n\n\t\tvar i = undefined,\n\t\t    j = undefined,\n\t\t    line = undefined,\n\t\t    generatedCodeColumn = undefined,\n\t\t    decodedLine = undefined,\n\t\t    segments = undefined,\n\t\t    segment = undefined,\n\t\t    result = undefined;\n\n\t\tfor (i = 0; i < numLines; i += 1) {\n\t\t\tline = lines[i];\n\n\t\t\tgeneratedCodeColumn = 0; // first field - reset each time\n\t\t\tdecodedLine = [];\n\n\t\t\tsegments = decodeSegments(line.split(','));\n\n\t\t\tfor (j = 0; j < segments.length; j += 1) {\n\t\t\t\tsegment = segments[j];\n\n\t\t\t\tif (!segment.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tgeneratedCodeColumn += segment[0];\n\n\t\t\t\tresult = [generatedCodeColumn];\n\t\t\t\tdecodedLine.push(result);\n\n\t\t\t\tif (segment.length === 1) {\n\t\t\t\t\t// only one field!\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsourceFileIndex += segment[1];\n\t\t\t\tsourceCodeLine += segment[2];\n\t\t\t\tsourceCodeColumn += segment[3];\n\n\t\t\t\tresult.push(sourceFileIndex, sourceCodeLine, sourceCodeColumn);\n\n\t\t\t\tif (segment.length === 5) {\n\t\t\t\t\tnameIndex += segment[4];\n\t\t\t\t\tresult.push(nameIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded[i] = decodedLine;\n\t\t}\n\n\t\tcache[checksum] = decoded;\n\t}\n\n\treturn cache[checksum];\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/decodeMappings.js.map\n","/**\n * Decodes a base64 string\n * @param {string} base64 - the string to decode\n * @returns {string}\n */\nexport default atob;\n\nfunction atob(base64) {\n  return new Buffer(base64, 'base64').toString('utf8');\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/atob.js.map\n","\n\n/**\n * Turns a sourceMappingURL into a sourcemap\n * @param {string} url - the URL (i.e. sourceMappingURL=url). Can\n   be a base64-encoded data URI\n * @param {string} base - the URL against which relative URLS\n   should be resolved\n * @param {boolean} sync - if `true`, return a promise, otherwise\n   return the sourcemap\n * @returns {object} - a version 3 sourcemap\n */\nexport default getMapFromUrl;\nimport path from 'path';\nimport sander from 'sander';\nimport atob from './atob';\nfunction getMapFromUrl(url, base, sync) {\n\tif (/^data/.test(url)) {\n\t\tvar match = /base64,(.+)$/.exec(url);\n\n\t\tif (!match) {\n\t\t\tthrow new Error('sourceMappingURL is not base64-encoded');\n\t\t}\n\n\t\tvar json = atob(match[1]);\n\t\tvar map = JSON.parse(json);\n\t\treturn sync ? map : sander.Promise.resolve(map);\n\t}\n\n\turl = path.resolve(path.dirname(base), decodeURI(url));\n\n\tif (sync) {\n\t\treturn JSON.parse(sander.readFileSync(url).toString());\n\t} else {\n\t\treturn sander.readFile(url).then(String).then(JSON.parse);\n\t}\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/getMapFromUrl.js.map\n","export default getSourceMappingUrl;\n\nfunction getSourceMappingUrl(str) {\n\tvar index, substring, url, match;\n\n\t// assume we want the last occurence\n\tindex = str.lastIndexOf('sourceMappingURL=');\n\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\tsubstring = str.substring(index + 17);\n\tmatch = /^[^\\r\\n]+/.exec(substring);\n\n\turl = match ? match[0] : null;\n\n\t// possibly a better way to do this, but we don't want to exclude whitespace\n\t// from the sourceMappingURL because it might not have been correctly encoded\n\tif (url && url.slice(-2) === '*/') {\n\t\turl = url.slice(0, -2).trim();\n\t}\n\n\treturn url;\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/getSourceMappingUrl.js.map\n","\n\nexport default getMap;\nimport getMapFromUrl from './getMapFromUrl';\nimport getSourceMappingUrl from './getSourceMappingUrl';\nimport { Promise } from 'sander';\nfunction getMap(node, sourceMapByPath, sync) {\n\tif (node.file in sourceMapByPath) {\n\t\tvar map = sourceMapByPath[node.file];\n\t\treturn sync ? map : Promise.resolve(map);\n\t} else {\n\t\tvar url = getSourceMappingUrl(node.content);\n\n\t\tif (!url) {\n\t\t\tnode.isOriginalSource = true;\n\t\t\treturn sync ? null : Promise.resolve(null);\n\t\t}\n\n\t\treturn getMapFromUrl(url, node.file, sync);\n\t}\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/getMap.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport path from 'path';\nimport sander from 'sander';\nimport decodeMappings from './utils/decodeMappings';\nimport getMap from './utils/getMap';\n\nvar Promise = sander.Promise;\n\nvar Node = (function () {\n\tfunction Node(_ref) {\n\t\tvar file = _ref.file;\n\t\tvar content = _ref.content;\n\n\t\t_classCallCheck(this, Node);\n\n\t\tthis.file = file ? path.resolve(file) : null;\n\t\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\t\tif (!this.file && this.content === null) {\n\t\t\tthrow new Error('A source must specify either file or content');\n\t\t}\n\n\t\t// these get filled in later\n\t\tthis.map = null;\n\t\tthis.mappings = null;\n\t\tthis.sources = null;\n\t\tthis.isOriginalSource = null;\n\n\t\tthis._stats = {\n\t\t\tdecodingTime: 0,\n\t\t\tencodingTime: 0,\n\t\t\ttracingTime: 0,\n\n\t\t\tuntraceable: 0\n\t\t};\n\t}\n\n\tNode.prototype.load = function load(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this = this;\n\n\t\treturn getContent(this, sourcesContentByPath).then(function (content) {\n\t\t\t_this.content = sourcesContentByPath[_this.file] = content;\n\n\t\t\treturn getMap(_this, sourceMapByPath).then(function (map) {\n\t\t\t\tif (!map) return null;\n\n\t\t\t\t_this.map = map;\n\n\t\t\t\tvar decodingStart = process.hrtime();\n\t\t\t\t_this.mappings = decodeMappings(map.mappings);\n\t\t\t\tvar decodingTime = process.hrtime(decodingStart);\n\t\t\t\t_this._stats.decodingTime = 1000000000 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tvar sourcesContent = map.sourcesContent || [];\n\n\t\t\t\t_this.sources = map.sources.map(function (source, i) {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? resolveSourcePath(_this, map.sourceRoot, source) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tvar promises = _this.sources.map(function (node) {\n\t\t\t\t\treturn node.load(sourcesContentByPath, sourceMapByPath);\n\t\t\t\t});\n\t\t\t\treturn Promise.all(promises);\n\t\t\t});\n\t\t});\n\t};\n\n\tNode.prototype.loadSync = function loadSync(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this2 = this;\n\n\t\tif (!this.content) {\n\t\t\tthis.content = sourcesContentByPath[this.file] = sander.readFileSync(this.file).toString();\n\t\t}\n\n\t\tvar map = getMap(this, sourceMapByPath, true);\n\t\tvar sourcesContent = undefined;\n\n\t\tif (!map) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = decodeMappings(map.mappings);\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tthis.sources = map.sources.map(function (source, i) {\n\t\t\t\tvar node = new Node({\n\t\t\t\t\tfile: resolveSourcePath(_this2, map.sourceRoot, source),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Traces a segment back to its origin\n  * @param {number} lineIndex - the zero-based line index of the\n    segment as found in `this`\n  * @param {number} columnIndex - the zero-based column index of the\n    segment as found in `this`\n  * @param {string || null} - if specified, the name that should be\n    (eventually) returned, as it is closest to the generated code\n  * @returns {object}\n      @property {string} source - the filepath of the source\n      @property {number} line - the one-based line index\n      @property {number} column - the zero-based column index\n      @property {string || null} name - the name corresponding\n      to the segment being traced\n  */\n\n\tNode.prototype.trace = function trace(lineIndex, columnIndex, name) {\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif (this.isOriginalSource) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tvar segments = this.mappings[lineIndex];\n\n\t\tif (!segments || segments.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (columnIndex != null) {\n\t\t\tvar len = segments.length;\n\t\t\tvar i = undefined;\n\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tvar generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif (generatedCodeColumn > columnIndex) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (generatedCodeColumn === columnIndex) {\n\t\t\t\t\tvar _sourceFileIndex = segments[i][1];\n\t\t\t\t\tvar _sourceCodeLine = segments[i][2];\n\t\t\t\t\tvar sourceCodeColumn = segments[i][3];\n\t\t\t\t\tvar _nameIndex = segments[i][4];\n\n\t\t\t\t\tvar _parent = this.sources[_sourceFileIndex];\n\t\t\t\t\treturn _parent.trace(_sourceCodeLine, sourceCodeColumn, this.map.names[_nameIndex] || name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tvar sourceFileIndex = segments[0][1];\n\t\tvar sourceCodeLine = segments[0][2];\n\t\tvar nameIndex = segments[0][4];\n\n\t\tvar parent = this.sources[sourceFileIndex];\n\t\treturn parent.trace(sourceCodeLine, null, this.map.names[nameIndex] || name);\n\t};\n\n\treturn Node;\n})();\n\nexport default Node;\n\nfunction getContent(node, sourcesContentByPath) {\n\tif (node.file in sourcesContentByPath) {\n\t\tnode.content = sourcesContentByPath[node.file];\n\t}\n\n\tif (!node.content) {\n\t\treturn sander.readFile(node.file).then(String);\n\t}\n\n\treturn Promise.resolve(node.content);\n}\n\nfunction resolveSourcePath(node, sourceRoot, source) {\n\treturn path.resolve(path.dirname(node.file), sourceRoot || '', source);\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Node.js.map\n","/**\n * Encodes a string as base64\n * @param {string} str - the string to encode\n * @returns {string}\n */\nexport default btoa;\n\nfunction btoa(str) {\n  return new Buffer(str).toString('base64');\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/btoa.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport btoa from './utils/btoa';\n\nvar SourceMap = (function () {\n\tfunction SourceMap(properties) {\n\t\t_classCallCheck(this, SourceMap);\n\n\t\tthis.version = 3;\n\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = properties.mappings;\n\t}\n\n\tSourceMap.prototype.toString = function toString() {\n\t\treturn JSON.stringify(this);\n\t};\n\n\tSourceMap.prototype.toUrl = function toUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t};\n\n\treturn SourceMap;\n})();\n\nexport default SourceMap;\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/SourceMap.js.map\n","\n\nexport default encodeMappings;\nimport * as vlq from 'vlq';\nfunction encodeMappings(decoded) {\n\tvar offsets = {\n\t\tgeneratedCodeColumn: 0,\n\t\tsourceFileIndex: 0, // second field\n\t\tsourceCodeLine: 0, // third field\n\t\tsourceCodeColumn: 0, // fourth field\n\t\tnameIndex: 0 // fifth field\n\t};\n\n\treturn decoded.map(function (line) {\n\t\toffsets.generatedCodeColumn = 0; // first field - reset each time\n\t\treturn line.map(encodeSegment).join(',');\n\t}).join(';');\n\n\tfunction encodeSegment(segment) {\n\t\tif (!segment.length) {\n\t\t\treturn segment;\n\t\t}\n\n\t\tvar result = new Array(segment.length);\n\n\t\tresult[0] = segment[0] - offsets.generatedCodeColumn;\n\t\toffsets.generatedCodeColumn = segment[0];\n\n\t\tif (segment.length === 1) {\n\t\t\t// only one field!\n\t\t\treturn result;\n\t\t}\n\n\t\tresult[1] = segment[1] - offsets.sourceFileIndex;\n\t\tresult[2] = segment[2] - offsets.sourceCodeLine;\n\t\tresult[3] = segment[3] - offsets.sourceCodeColumn;\n\n\t\toffsets.sourceFileIndex = segment[1];\n\t\toffsets.sourceCodeLine = segment[2];\n\t\toffsets.sourceCodeColumn = segment[3];\n\n\t\tif (segment.length === 5) {\n\t\t\tresult[4] = segment[4] - offsets.nameIndex;\n\t\t\toffsets.nameIndex = segment[4];\n\t\t}\n\n\t\treturn vlq.encode(result);\n\t}\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/encodeMappings.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport sander from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [sander.writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(sander.writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n","\n\nexport { load };\n\nexport { loadSync };\n\nimport { resolve } from 'path';\nimport Node from './Node';\nimport Chain from './Chain';\nfunction load(file, options) {\n\tvar _init = init(file, options);\n\n\tvar node = _init.node;\n\tvar sourcesContentByPath = _init.sourcesContentByPath;\n\tvar sourceMapByPath = _init.sourceMapByPath;\n\n\treturn node.load(sourcesContentByPath, sourceMapByPath).then(function () {\n\t\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n\t});\n}\n\nfunction loadSync(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar _init2 = init(file, options);\n\n\tvar node = _init2.node;\n\tvar sourcesContentByPath = _init2.sourcesContentByPath;\n\tvar sourceMapByPath = _init2.sourceMapByPath;\n\n\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n}\n\nfunction init(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar node = new Node({ file: file });\n\n\tvar sourcesContentByPath = {};\n\tvar sourceMapByPath = {};\n\n\tif (options.content) {\n\t\tObject.keys(options.content).forEach(function (key) {\n\t\t\tsourcesContentByPath[resolve(key)] = options.content[key];\n\t\t});\n\t}\n\n\tif (options.sourcemaps) {\n\t\tObject.keys(options.sourcemaps).forEach(function (key) {\n\t\t\tsourceMapByPath[resolve(key)] = options.sourcemaps[key];\n\t\t});\n\t}\n\n\treturn { node: node, sourcesContentByPath: sourcesContentByPath, sourceMapByPath: sourceMapByPath };\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/index.js.map\n"],"names":[],"mappings":";;;;;;;;;AAMA,IAAI,QAAQ;;AAEZ,SAAS,eAAe,iBAAiB;AACzC,CAAC,IAAI,IAAI,gBAAgB;AACzB,CAAC,IAAI,WAAW,IAAI,MAAM;;AAE1B,CAAC,OAAO,KAAK;AACb,EAAE,SAAS,KAAK,IAAI,OAAO,gBAAgB;AAC3C;;AAEA,CAAC,OAAO;AACR;AACA,SAAS,eAAe,UAAU;AAClC,CAAC,IAAI,WAnBL,YAmBqB,CAAC;;AAEtB,CAAC,IAAI,CAAC,MAAM,WAAW;AACvB,EAAE,IAAI,kBAAkB;AACxB,EAAE,IAAI,iBAAiB;AACvB,EAAE,IAAI,mBAAmB;AACzB,EAAE,IAAI,YAAY;;AAElB,EAAE,IAAI,QAAQ,SAAS,MAAM;AAC7B,EAAE,IAAI,WAAW,MAAM;AACvB,EAAE,IAAI,UAAU,IAAI,MAAM;;AAE1B,EAAE,IAAI,IAAI;AACV,MAAM,IAAI;AACV,MAAM,OAAO;AACb,MAAM,sBAAsB;AAC5B,MAAM,cAAc;AACpB,MAAM,WAAW;AACjB,MAAM,UAAU;AAChB,MAAM,SAAS;;AAEf,EAAE,KAAK,IAAI,GAAG,IAAI,UAAU,KAAK,GAAG;AACpC,GAAG,OAAO,MAAM;;AAEhB,GAAG,sBAAsB;AACzB,GAAG,cAAc;;AAEjB,GAAG,WAAW,eAAe,KAAK,MAAM;;AAExC,GAAG,KAAK,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,GAAG;AAC5C,IAAI,UAAU,SAAS;;AAEvB,IAAI,IAAI,CAAC,QAAQ,QAAQ;AACzB,KAAK;AACL;;AAEA,IAAI,uBAAuB,QAAQ;;AAEnC,IAAI,SAAS,CAAC;AACd,IAAI,YAAY,KAAK;;AAErB,IAAI,IAAI,QAAQ,WAAW,GAAG;AAC9B;AACA,KAAK;AACL;;AAEA,IAAI,mBAAmB,QAAQ;AAC/B,IAAI,kBAAkB,QAAQ;AAC9B,IAAI,oBAAoB,QAAQ;;AAEhC,IAAI,OAAO,KAAK,iBAAiB,gBAAgB;;AAEjD,IAAI,IAAI,QAAQ,WAAW,GAAG;AAC9B,KAAK,aAAa,QAAQ;AAC1B,KAAK,OAAO,KAAK;AACjB;AACA;;AAEA,GAAG,QAAQ,KAAK;AAChB;;AAEA,EAAE,MAAM,YAAY;AACpB;;AAEA,CAAC,OAAO,MAAM;AACd;;ACpFA;AACA;AACA;AACA;AACA;;;AAGA,SAAS,KAAK,QAAQ;AACtB,EAAE,OAAO,IAAI,OAAO,QAAQ,UAAU,SAAS;AAC/C;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKA,SAAS,cAAc,KAAK,MAAM,MAAM;AACxC,CAAC,IAAI,QAAQ,KAAK,MAAM;AACxB,EAAE,IAAI,QAAQ,eAAe,KAAK;;AAElC,EAAE,IAAI,CAAC,OAAO;AACd,GAAG,MAAM,IAAI,MAAM;AACnB;;AAEA,EAAE,IAAI,OAAO,KAAK,MAAM;AACxB,EAAE,IAAI,MAAM,KAAK,MAAM;AACvB,EAAE,OAAO,OAAO,MA1BhB,eA0B4B,CAAC,QAAQ,QAAQ;AAC7C;;AAEA,CAAC,MA7BD,aA6BW,CAAC,QA7BZ,aA6BwB,CAAC,QAAQ,OAAO,UAAU;;AAElD,CAAC,IAAI,MAAM;AACX,EAAE,OAAO,KAAK,MAhCd,eAgC0B,CAAC,aAAa,KAAK;AAC7C,QAAQ;AACR,EAAE,OAlCF,eAkCe,CAAC,SAAS,KAAK,KAAK,QAAQ,KAAK,KAAK;AACrD;AACA;;AClCA,SAAS,oBAAoB,KAAK;AAClC,CAAC,IAAI,OAAO,WAAW,KAAK;;AAE5B;AACA,CAAC,QAAQ,IAAI,YAAY;;AAEzB,CAAC,IAAI,UAAU,CAAC,GAAG;AACnB,EAAE,OAAO;AACT;;AAEA,CAAC,YAAY,IAAI,UAAU,QAAQ;AACnC,CAAC,QAAQ,YAAY,KAAK;;AAE1B,CAAC,MAAM,QAAQ,MAAM,KAAK;;AAE1B;AACA;AACA,CAAC,IAAI,OAAO,IAAI,MAAM,CAAC,OAAO,MAAM;AACpC,EAAE,MAAM,IAAI,MAAM,GAAG,CAAC,GAAG;AACzB;;AAEA,CAAC,OAAO;AACR;;AClBA,SAAS,OAAO,MAAM,iBAAiB,MAAM;AAC7C,CAAC,IAAI,KAAK,QAAQ,iBAAiB;AACnC,EAAE,IAAI,MAAM,gBAAgB,KAAK;AACjC,EAAE,OAAO,OAAO,MAThB,cAS6B,CAAC,QAAQ;AACtC,QAAQ;AACR,EAAE,IAAI,MAAM,oBAAoB,KAAK;;AAErC,EAAE,IAAI,CAAC,KAAK;AACZ,GAAG,KAAK,mBAAmB;AAC3B,GAAG,OAAO,OAAO,OAfjB,cAe+B,CAAC,QAAQ;AACxC;;AAEA,EAAE,OAAO,cAAc,KAAK,KAAK,MAAM;AACvC;AACA;;ACpBA,IAAA,qBAAmB,GAAG,UAAU,UAAU,aAAa,EAAE,IAAI,EAAE,oBAAoB,cAAc,EAAE,MAAM,IAAI,UAAU;;AAOvH,IAPA,aAOW,GAPX,eAOoB,CAAC;;AAErB,IAAI,OAAO,CAAC,YAAY;AACxB,CAAC,SAAS,KAAK,MAAM;AACrB,EAAE,IAAI,OAAO,KAAK;AAClB,EAAE,IAAI,UAAU,KAAK;;AAErB,EAdA,qBAciB,CAAC,MAAM;;AAExB,EAAE,KAAK,OAAO,OAhBd,aAgByB,CAAC,QAAQ,QAAQ;AAC1C,EAAE,KAAK,UAAU,WAAW;;AAE5B,EAAE,IAAI,CAAC,KAAK,QAAQ,KAAK,YAAY,MAAM;AAC3C,GAAG,MAAM,IAAI,MAAM;AACnB;;AAEA;AACA,EAAE,KAAK,MAAM;AACb,EAAE,KAAK,WAAW;AAClB,EAAE,KAAK,UAAU;AACjB,EAAE,KAAK,mBAAmB;;AAE1B,EAAE,KAAK,SAAS;AAChB,GAAG,cAAc;AACjB,GAAG,cAAc;AACjB,GAAG,aAAa;;AAEhB,GAAG,aAAa;AAChB;AACA;;AAEA,CAAC,KAAK,UAAU,OAAO,SAAS,KAAK,sBAAsB,iBAAiB;AAC5E,EAAE,IAAI,QAAQ;;AAEd,EAAE,OAAO,WAAW,MAAM,sBAAsB,KAAK,UAAU,SAAS;AACxE,GAAG,MAAM,UAAU,qBAAqB,MAAM,QAAQ;;AAEtD,GAAG,OAAO,OAAO,OAAO,iBAAiB,KAAK,UAAU,KAAK;AAC7D,IAAI,IAAI,CAAC,KAAK,OAAO;;AAErB,IAAI,MAAM,MAAM;;AAEhB,IAAI,IAAI,gBAAgB,QAAQ;AAChC,IAAI,MAAM,WAAW,eAAe,IAAI;AACxC,IAAI,IAAI,eAAe,QAAQ,OAAO;AACtC,IAAI,MAAM,OAAO,eAAe,aAAa,aAAa,KAAK,aAAa;;AAE5E,IAAI,IAAI,iBAAiB,IAAI,kBAAkB;;AAE/C,IAAI,MAAM,UAAU,IAAI,QAAQ,IAAI,UAAU,QAAQ,GAAG;AACzD,KAAK,OAAO,IAAI,KAAK;AACrB,MAAM,MAAM,SAAS,kBAAkB,OAAO,IAAI,YAAY,UAAU;AACxE,MAAM,SAAS,eAAe;AAC9B;AACA;;AAEA,IAAI,IAAI,WAAW,MAAM,QAAQ,IAAI,UAAU,MAAM;AACrD,KAAK,OAAO,KAAK,KAAK,sBAAsB;AAC5C;AACA,IAAI,OAlEJ,aAkEkB,CAAC,IAAI;AACvB;AACA;AACA;;AAEA,CAAC,KAAK,UAAU,WAAW,SAAS,SAAS,sBAAsB,iBAAiB;AACpF,EAAE,IAAI,SAAS;;AAEf,EAAE,IAAI,CAAC,KAAK,SAAS;AACrB,GAAG,KAAK,UAAU,qBAAqB,KAAK,QA3E5C,eA2E0D,CAAC,aAAa,KAAK,MAAM;AACnF;;AAEA,EAAE,IAAI,MAAM,OAAO,MAAM,iBAAiB;AAC1C,EAAE,IAAI,iBAAiB;;AAEvB,EAAE,IAAI,CAAC,KAAK;AACZ,GAAG,KAAK,mBAAmB;AAC3B,SAAS;AACT,GAAG,KAAK,MAAM;AACd,GAAG,KAAK,WAAW,eAAe,IAAI;;AAEtC,GAAG,iBAAiB,IAAI,kBAAkB;;AAE1C,GAAG,KAAK,UAAU,IAAI,QAAQ,IAAI,UAAU,QAAQ,GAAG;AACvD,IAAI,IAAI,OAAO,IAAI,KAAK;AACxB,KAAK,MAAM,kBAAkB,QAAQ,IAAI,YAAY;AACrD,KAAK,SAAS,eAAe;AAC7B;;AAEA,IAAI,KAAK,SAAS,sBAAsB;AACxC,IAAI,OAAO;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,KAAK,UAAU,QAAQ,SAAS,MAAM,WAAW,aAAa,MAAM;AACrE;AACA;AACA,EAAE,IAAI,KAAK,kBAAkB;AAC7B,GAAG,OAAO;AACV,IAAI,QAAQ,KAAK;AACjB,IAAI,MAAM,YAAY;AACtB,IAAI,QAAQ,eAAe;AAC3B,IAAI,MAAM;AACV;AACA;;AAEA;AACA;AACA,EAAE,IAAI,WAAW,KAAK,SAAS;;AAE/B,EAAE,IAAI,CAAC,YAAY,SAAS,WAAW,GAAG;AAC1C,GAAG,OAAO;AACV;;AAEA,EAAE,IAAI,eAAe,MAAM;AAC3B,GAAG,IAAI,MAAM,SAAS;AACtB,GAAG,IAAI,IAAI;;AAEX,GAAG,KAAK,IAAI,GAAG,IAAI,KAAK,KAAK,GAAG;AAChC,IAAI,IAAI,sBAAsB,SAAS,GAAG;;AAE1C,IAAI,IAAI,sBAAsB,aAAa;AAC3C,KAAK;AACL;;AAEA,IAAI,IAAI,wBAAwB,aAAa;AAC7C,KAAK,IAAI,mBAAmB,SAAS,GAAG;AACxC,KAAK,IAAI,kBAAkB,SAAS,GAAG;AACvC,KAAK,IAAI,mBAAmB,SAAS,GAAG;AACxC,KAAK,IAAI,aAAa,SAAS,GAAG;;AAElC,KAAK,IAAI,UAAU,KAAK,QAAQ;AAChC,KAAK,OAAO,QAAQ,MAAM,iBAAiB,kBAAkB,KAAK,IAAI,MAAM,eAAe;AAC3F;AACA;AACA;;AAEA;AACA,EAAE,IAAI,kBAAkB,SAAS,GAAG;AACpC,EAAE,IAAI,iBAAiB,SAAS,GAAG;AACnC,EAAE,IAAI,YAAY,SAAS,GAAG;;AAE9B,EAAE,IAAI,SAAS,KAAK,QAAQ;AAC5B,EAAE,OAAO,OAAO,MAAM,gBAAgB,MAAM,KAAK,IAAI,MAAM,cAAc;AACzE;;AAEA,CAAC,OAAO;AACR;;;;AAIA,SAAS,WAAW,MAAM,sBAAsB;AAChD,CAAC,IAAI,KAAK,QAAQ,sBAAsB;AACxC,EAAE,KAAK,UAAU,qBAAqB,KAAK;AAC3C;;AAEA,CAAC,IAAI,CAAC,KAAK,SAAS;AACpB,EAAE,OApLF,eAoLe,CAAC,SAAS,KAAK,MAAM,KAAK;AACzC;;AAEA,CAAC,OAvLD,aAuLe,CAAC,QAAQ,KAAK;AAC7B;;AAEA,SAAS,kBAAkB,MAAM,YAAY,QAAQ;AACrD,CAAC,OA3LD,aA2LY,CAAC,QA3Lb,aA2LyB,CAAC,QAAQ,KAAK,OAAO,cAAc,IAAI;AAChE;;AC5LA;AACA;AACA;AACA;AACA;;;AAGA,SAAS,KAAK,KAAK;AACnB,EAAE,OAAO,IAAI,OAAO,KAAK,SAAS;AAClC;;ACTA,IAAA,0BAAmB,GAAG,UAAU,UAAU,aAAa,EAAE,IAAI,EAAE,oBAAoB,cAAc,EAAE,MAAM,IAAI,UAAU;;AAIvH,IAAI,YAAY,CAAC,YAAY;AAC7B,CAAC,SAAS,UAAU,YAAY;AAChC,EANA,0BAMiB,CAAC,MAAM;;AAExB,EAAE,KAAK,UAAU;;AAEjB,EAAE,KAAK,OAAO,WAAW;AACzB,EAAE,KAAK,UAAU,WAAW;AAC5B,EAAE,KAAK,iBAAiB,WAAW;AACnC,EAAE,KAAK,QAAQ,WAAW;AAC1B,EAAE,KAAK,WAAW,WAAW;AAC7B;;AAEA,CAAC,UAAU,UAAU,WAAW,SAAS,WAAW;AACpD,EAAE,OAAO,KAAK,UAAU;AACxB;;AAEA,CAAC,UAAU,UAAU,QAAQ,SAAS,QAAQ;AAC9C,EAAE,OAAO,gDAAgD,KAAK,KAAK;AACnE;;AAEA,CAAC,OAAO;AACR;;ACtBA,SAAS,eAAe,SAAS;AACjC,CAAC,IAAI,UAAU;AACf,EAAE,qBAAqB;AACvB,EAAE,iBAAiB;AACnB,EAAE,gBAAgB;AAClB,EAAE,kBAAkB;AACpB,EAAE,WAAW;AACb;;AAEA,CAAC,OAAO,QAAQ,IAAI,UAAU,MAAM;AACpC,EAAE,QAAQ,sBAAsB;AAChC,EAAE,OAAO,KAAK,IAAI,eAAe,KAAK;AACtC,IAAI,KAAK;;AAET,CAAC,SAAS,cAAc,SAAS;AACjC,EAAE,IAAI,CAAC,QAAQ,QAAQ;AACvB,GAAG,OAAO;AACV;;AAEA,EAAE,IAAI,SAAS,IAAI,MAAM,QAAQ;;AAEjC,EAAE,OAAO,KAAK,QAAQ,KAAK,QAAQ;AACnC,EAAE,QAAQ,sBAAsB,QAAQ;;AAExC,EAAE,IAAI,QAAQ,WAAW,GAAG;AAC5B;AACA,GAAG,OAAO;AACV;;AAEA,EAAE,OAAO,KAAK,QAAQ,KAAK,QAAQ;AACnC,EAAE,OAAO,KAAK,QAAQ,KAAK,QAAQ;AACnC,EAAE,OAAO,KAAK,QAAQ,KAAK,QAAQ;;AAEnC,EAAE,QAAQ,kBAAkB,QAAQ;AACpC,EAAE,QAAQ,iBAAiB,QAAQ;AACnC,EAAE,QAAQ,mBAAmB,QAAQ;;AAErC,EAAE,IAAI,QAAQ,WAAW,GAAG;AAC5B,GAAG,OAAO,KAAK,QAAQ,KAAK,QAAQ;AACpC,GAAG,QAAQ,YAAY,QAAQ;AAC/B;;AAEA,EAAE,OAAO,IAAI,OAAO;AACpB;AACA;;AChDA,IAAA,sBAAmB,GAAG,UAAU,UAAU,aAAa,EAAE,IAAI,EAAE,oBAAoB,cAAc,EAAE,MAAM,IAAI,UAAU;;AAOvH,IAAI,oBAAoB;AACxB,qBAAqB;;AAErB,IAAI,oBAAoB,IAAI,OAAO,YAAY,mBAAmB,oBAAoB;AACtF,iBAAiB,oBAAoB;AACrC,SAAS;;AAET,IAAI,QAAQ,CAAC,YAAY;AACzB,CAAC,SAAS,MAAM,MAAM,sBAAsB;AAC5C,EAhBA,sBAgBiB,CAAC,MAAM;;AAExB,EAAE,KAAK,OAAO;AACd,EAAE,KAAK,uBAAuB;;AAE9B,EAAE,KAAK,SAAS;AAChB;;AAEA,CAAC,MAAM,UAAU,OAAO,SAAS,OAAO;AACxC,EAAE,OAAO;AACT,GAAG,kBAAkB,KAAK,OAAO,eAAe;AAChD,GAAG,mBAAmB,CAAC,KAAK,OAAO,eAAe,MAAM,KAAK,KAAK,SAAS,mBAAmB;;AAE9F,GAAG,cAAc,KAAK,OAAO,eAAe;AAC5C,GAAG,aAAa,KAAK,OAAO,cAAc;;AAE1C,GAAG,aAAa,KAAK,OAAO;AAC5B;AACA;;AAEA,CAAC,MAAM,UAAU,QAAQ,SAAS,QAAQ;AAC1C,EAAE,IAAI,QAAQ;;AAEd,EAAE,IAAI,UAAU,UAAU,OAAO,YAAY,KAAK,UAAU;;AAE5D,EAAE,IAAI,WAAW;AACjB,EAAE,IAAI,aAAa;;AAEnB,EAAE,IAAI,eAAe,UAAU,SAAS,QAAQ;AAChD,GAAG,IAAI,SAAS,MAAM,KAAK,QAAQ,QAAQ,IAAI;AAC/C,GAAG,QAAQ;AACX,GAAG,QAAQ;AACX,GAAG,MAAM,KAAK,IAAI,MAAM,QAAQ;;AAEhC,GAAG,IAAI,CAAC,QAAQ;AAChB,IAAI,MAAM,OAAO,eAAe;AAChC,IAAI;AACJ;;AAEA,GAAG,IAAI,cAAc,WAAW,QAAQ,OAAO;AAC/C,GAAG,IAAI,EAAE,CAAC,aAAa;AACvB,IAAI,cAAc,WAAW;AAC7B,IAAI,WAAW,KAAK,OAAO;AAC3B;;AAEA,GAAG,IAAI,aAAa,CAAC,QAAQ;AAC7B,GAAG,aAAa,OAAO,OAAO,GAAG,OAAO;;AAExC,GAAG,IAAI,OAAO,MAAM;AACpB,IAAI,IAAI,YAAY,SAAS,QAAQ,OAAO;AAC5C,IAAI,IAAI,EAAE,CAAC,WAAW;AACtB,KAAK,YAAY,SAAS;AAC1B,KAAK,SAAS,KAAK,OAAO;AAC1B;;AAEA,IAAI,WAAW,KAAK;AACpB;;AAEA,GAAG,OAAO,OAAO,UAAU;AAC3B;;AAEA;AACA,EAAE,IAAI,eAAe,QAAQ;;AAE7B,EAAE,IAAI,IAAI,KAAK,KAAK,SAAS;AAC7B,EAAE,IAAI,WAAW,IAAI,MAAM;;AAE3B,EAAE,IAAI,IAAI;AACV,MAAM,OAAO;AACb,MAAM,SAAS;;AAEf,EAAE,OAAO,KAAK;AACd,GAAG,OAAO,KAAK,KAAK,SAAS;AAC7B,GAAG,SAAS,KAAK,SAAS;;AAE1B,GAAG,KAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACxC,IAAI,aAAa,KAAK,IAAI;AAC1B;AACA;;AAEA,EAAE,IAAI,cAAc,QAAQ,OAAO;AACnC,EAAE,KAAK,OAAO,cAAc,aAAa,YAAY,KAAK,YAAY;;AAEtE;AACA,EAAE,IAAI,gBAAgB,QAAQ;AAC9B,EAAE,IAAI,WAAW,eAAe;AAChC,EAAE,IAAI,eAAe,QAAQ,OAAO;AACpC,EAAE,KAAK,OAAO,eAAe,aAAa,aAAa,KAAK,aAAa;;AAEzE,EAAE,IAAI,iBAAiB,QAAQ,mBAAmB;;AAElD,EAAE,OAAO,IAAI,UAAU;AACvB,GAAG,MA5GH,aA4GiB,CAAC,KAAK,KAAK;AAC5B,GAAG,SAAS,WAAW,IAAI,UAAU,QAAQ;AAC7C,IAAI,OA9GJ,aA8GmB,CAAC,QAAQ,QA9G5B,YA8G2C,CAAC,MAAM,KAAK,OAAO;AAC9D;AACA,GAAG,gBAAgB,WAAW,IAAI,UAAU,QAAQ;AACpD,IAAI,OAAO,iBAAiB,MAAM,qBAAqB,UAAU;AACjE;AACA,GAAG,OAAO;AACV,GAAG,UAAU;AACb;AACA;;AAEA,CAAC,MAAM,UAAU,QAAQ,SAAS,MAAM,mBAAmB,sBAAsB;AACjF,EAAE,OAAO,KAAK,KAAK,MAAM,oBAAoB,GAAG,sBAAsB;AACtE;;AAEA,CAAC,MAAM,UAAU,QAAQ,SAAS,MAAM,MAAM,SAAS;AACvD,EAAE,IAAI,OAAO,SAAS,UAAU;AAChC,GAAG,UAAU;AACb,GAAG,OAAO,KAAK,KAAK;AACpB;;AAEA,EAAE,UAAU,WAAW;AACvB,EAAE,OAnIF,YAmIgB,CAAC;;AAEjB,EAAE,IAAI,MAAM,KAAK,MAAM;AACvB,GAAG,gBAAgB,QAAQ;AAC3B,GAAG,MAAM,QAAQ,OAvIjB,YAuI+B,CAAC,QAAQ,QAvIxC,YAuIuD,CAAC;AACxD;;AAEA,EAAE,IAAI,MAAM,QAAQ,SAAS,IAAI,UAAU,CAAC,QAAQ,eAAe,OA1InE,aA0IkF,CAAC,SAAS;;AAE5F,EAAE,IAAI,UAAU,KAAK,KAAK,QAAQ,QAAQ,mBAAmB,MAAM,iBAAiB,KAAK;;AAEzF,EAAE,IAAI,WAAW,CA9IjB,eA8IwB,CAAC,UAAU,MAAM;;AAEzC,EAAE,IAAI,CAAC,QAAQ,QAAQ;AACvB,GAAG,SAAS,KAjJZ,eAiJuB,CAAC,UAAU,OAAO,QAAQ,IAAI;AACrD;;AAEA,EAAE,OAAO,QAAQ,IAAI;AACrB;;AAEA,CAAC,OAAO;AACR;;;;AAIA,SAAS,MAAM,OAAO,MAAM;AAC5B,CAAC,OAAO,MAAM,OAAO,UAAU,OAAO,MAAM;AAC5C,EAAE,OAAO,QAAQ,KAAK,OAAO;AAC7B,IAAI;AACJ;;AAEA,SAAS,iBAAiB,KAAK,MAAM;AACrC,CAAC,IAAI,MAnKL,YAmKkB,CAAC;AACnB,CAAC,MAAM,UAAU;;AAEjB,CAAC,IAAI,QAAQ,QAAQ;AACrB,EAAE,OAAO,WAAW,oBAAoB,MAAM,MAAM;AACpD;;AAEA,CAAC,OAAO,WAAW,oBAAoB,MAAM,MAAM;AACnD;;AClKA,SAAS,KAAK,MAAM,SAAS;AAC7B,CAAC,IAAI,QAAQ,KAAK,MAAM;;AAExB,CAAC,IAAI,OAAO,MAAM;AAClB,CAAC,IAAI,uBAAuB,MAAM;AAClC,CAAC,IAAI,kBAAkB,MAAM;;AAE7B,CAAC,OAAO,KAAK,KAAK,sBAAsB,iBAAiB,KAAK,YAAY;AAC1E,EAAE,OAAO,KAAK,mBAAmB,OAAO,IAAI,MAAM,MAAM;AACxD;AACA;;AAEA,SAAS,SAAS,MAAM;AACxB,CAAC,IAAI,UAAU,UAAU,OAAO,YAAY,KAAK,UAAU;;AAE3D,CAAC,IAAI,SAAS,KAAK,MAAM;;AAEzB,CAAC,IAAI,OAAO,OAAO;AACnB,CAAC,IAAI,uBAAuB,OAAO;AACnC,CAAC,IAAI,kBAAkB,OAAO;;AAE9B,CAAC,KAAK,SAAS,sBAAsB;AACrC,CAAC,OAAO,KAAK,mBAAmB,OAAO,IAAI,MAAM,MAAM;AACvD;;AAEA,SAAS,KAAK,MAAM;AACpB,CAAC,IAAI,UAAU,UAAU,OAAO,YAAY,KAAK,UAAU;;AAE3D,CAAC,IAAI,OAAO,IAAI,KAAK,EAAE,MAAM;;AAE7B,CAAC,IAAI,uBAAuB;AAC5B,CAAC,IAAI,kBAAkB;;AAEvB,CAAC,IAAI,QAAQ,SAAS;AACtB,EAAE,OAAO,KAAK,QAAQ,SAAS,QAAQ,UAAU,KAAK;AACtD,GAAG,qBA5CH,YA4C+B,CAAC,QAAQ,QAAQ,QAAQ;AACxD;AACA;;AAEA,CAAC,IAAI,QAAQ,YAAY;AACzB,EAAE,OAAO,KAAK,QAAQ,YAAY,QAAQ,UAAU,KAAK;AACzD,GAAG,gBAlDH,YAkD0B,CAAC,QAAQ,QAAQ,WAAW;AACtD;AACA;;AAEA,CAAC,OAAO,EAAE,MAAM,MAAM,sBAAsB,sBAAsB,iBAAiB;AACnF;;AAvDA;AAAA"}